#+TITLE: 编译原理复习笔记
#+DATE: 2018-01-07
#+SETUPFILE: ~/blog/setupfile.org
#+JEKYLL_LAYOUT: post
#+JEKYLL_CATEGORIES: review
#+JEKYLL_TAGS: exam
#+JEKYLL_PUBLISHED: true

* 编译概述
** 语言处理程序
- *定义* 使计算机能理解人们提供的命令与输入的程序。
| 分类     | 输入                   | 输出                                       |
|----------+------------------------+--------------------------------------------|
| 解释程序 | 用计算机语言编写的程序 | (执行该程序蕴含的运算)                     |
| 翻译程序 | (同上)                 | 目标语言（某个计算机的机器语言）编写的程序 |
- *编译系统* 编译程序与运行系统的合称。
- *目标机* 运行编译程序所产生目标代码的计算机。
- *交叉编译* 编译过程与编译输出的目标程序的执行在不同机器上完成时，这种编译称之。
** 编译程序的逻辑结构
#+BEGIN_EXPORT html
<img src="/images/compiler1.png" alt="Drawing" width="400px" />
#+END_EXPORT
*** 编译前端和后端
- *编译前端* 主要由与源语言有关的但与目标机无关的那些部分组成（通常包括词法分析，语法分析，语义分析与中间代码产生，有时候也包含代码优化）。
- *编译后端* 包括编译程序中与目标机有关的那些部分，仅仅依赖于中间语言（如与目标机有关的代码优化和目标代码生成等）。
- *优点* 便于实现编译程序的目标机改变。
** 词法分析
 分析源程序的结构，判断是否为相应程序中的一个合法程序。
** 语义分析
 规定各语法成分的含义或功能（规定它们的属性或在程序执行时应进行的运算及操作，语法检查）。
** 中间代码生成
*好处* 处理上方便，便于优化移植。
** 代码优化
*原因* 上述阶段较多的考虑语法与语义上的共性，而对源程序间出现的差异考虑较少，所以代码效率较低。
** 目标代码生成
- *目的* 接受中间代码，将其翻译为机器语言或汇编语言形式的目标程序。
- *要求* 生成代码尽可能短；充分发挥计算机可用资源的效率。
*目标代码的三种形式*
- 具有绝对地址的机器指令代码；
- 汇编语言形式的目标程序；
- 模块结构的机器代码；
** 错误检查和处理程序
报告错误的种类，出现的位置以及一定的纠错能力。
** 信息表管理
*三类数据*
- 编译程序带有的局部程序；
- 源程序正文的各种中间表示；
- 含有表示程序正文中上下文依赖关系的信息表格；
** 编译程序的组织
*多遍扫描的优点* 
- 采用模块结构，各遍功能独立，整个编译程序结构比较清晰；
- 多次扫描加工，有利于优化；
- 按模块逐次调入内存，有利于复盖技术的采用；
-----
* 文法和语言
*三种定义语言的方法*
- 枚举法
- 文法：定义有限条规则，来产生所需描述的语言中全部的句子；
- 自动机；
| 概念   | 定义                                           |
|--------+------------------------------------------------|
| 字母表 | 若干元素组成的有限非空集合，每个元素称之为符号 |
| 字符串 | 由字母表中符号组成的任何有限序列               |
** 文法定义
G[S]=(V_N ,V_T ,P,S)
| 符号 | 定义       |
|------+------------|
| V_N  | 非终结符集 |
| V_T  | 终结符集   |
| P    | 产生式集   |
| S    | 开始符号   |
** 文法和语言的关系
一个文法产生唯一的语言，但一个语言可由若干个不同的文法表示。
** 句型的分析
- *左句型* 能由最左推导推导出的句型成为左句型，同理可得右句型；
- *最右推导* 被称为 *规范推导*;
- 由规范推导推导出的句型称为 *规范句型*;
*** 最左推导
任何一步\alpha \Rightarrow \beta 都是对\alpha 中的最左非终结符进行替换。
*** 语法树和二义性
1. *语法树* 可以用来表示一个文法所描述语言的句型结构。
2. 如果一个文法所描述语言的某个句子对应不止一棵语法树，则成该文法为 *二义性文法* .
3. LL(1),LR(0)文法都是无二义性文法，若一个文法含有既是左递归又是右递归的非终结符，则该文法是二义性文法。
+ 一个句型的最左直接短语称为此句型的句柄。
** 文法简化和改造
*** 无用符号及无用产生式的消除
*** 单产生式的消除
** 文法和语言的乔姆斯基分类
*** 0型文法或短语结构文法PSG(0型语言，短语文法)
每个产生式\alpha \to \beta,\alpha \in (V_N \cup V_T )^* 且至少含有一个非终结符,\beta \in (V_N \cup V_T )^* 。
*** 1型文法或前后文有关文法CSG(1型语言)
在0型文法上增加限制，对于每个产生式：
\alpha \to \beta,|\alpha|\le|\beta|,仅仅S \to \epsilon 例外，但S不得出现在任何产生式的右部。
*** 2型文法或前后文无关文法CFG(2型语言)
非终结符的替换不考虑上下文：
A \to \beta ,A \in V_N , \beta \in (V_N \cup V_T )^* 。
*** 3型文法或正规文法（左线性文法和右线性文法）
*右线性文法* A \to\alpha B或A \to \alpha ,\alpha \in V_T^* ,A,B \in V_N 。
-----
* 程序设计语言
** 构造基础
- *基本功能* 定义运算对象和对对象的运算
- *分类* 数据型对象和程序型对象 
** 运行时存储管理
*存储分配策略*
- 静态分配
- 栈式动态分配
- 堆式动态分配
** 参数传递
- 传地址
- 传值
- 传结果
- 传值结果
- 传名
-----
* 词法分析
** 正规文法与状态转换图
状态矩阵；
** 有限自动机
*** 组成
 DFAM = ( K,\Sigma ,f,s_0,Z) 
| 符号 | K      | \Sigma | f        | s_0  | Z    |
| 定义 | 状态集 | 字母表 | 单值映射 | 初态 | 终态 |
*** 定理
1. 对于\Sigma 上任一NFAM必存在同一\Sigma 上等价DFAM;
*** 正规表达式与正规集
- 最小化算法；
- 具有\varepsilon 动作的有限自动机确定化；
-----
* 语法分析
** 分析方法
*** 自顶向下
- 确定：对文法有一定限制，但实现简单、直观；
- 不确定：实际上是穷举试探法，效率低代价高；
*** 自底向上
- 算符优先分析；
- LR分析；
** 自顶向下的语法分析
- 消除左递归；
- 解决回朔问题（提取公共左因子）；
- 确定符号串的错误地点；
*** LL(1) 文法
**** 条件
1. 文法不含左递归；
2. 对于文法中每个非终结符A的各个产生式的候选首符集两两不相交：A\to\alpha_1|\alpha_2|...|\alpha_n ,FIRST(\alpha_i) \cap FIRST(\alpha_j)=\phi;
3. 对于文法中每个非终结符A,若它存在某个候选式首符集包含\epsilon ,则FIRST(A) \cap FOLLOW(A)=\phi;
*** 结论
1. 任何LL1文法都不是二义性文法；
2. 左递归文法不是LL1文法；
3. 不存在一种算法能判断任意的前后文无关语言是否为LL1语言；
4. 非LL1语言是存在的；
5. 存在算法能判定任意文法是否为LL1文法；
6. 存在算法那个判定任意两个LL1文法是否产生相同的语言；
** 自底向上的语法分析
- 如何在规约过程中发现句柄；
*** 简单文法 
若一个文法G的任意两个符号间至多存在一种优先关系，并且任意两个不同产生式均无相同的右部。
*** 算符文法
若一个文法中不含有形如 U->...AB... 的产生式时，称为算符文法。
*** 算符优先文法
任何一对终结符之间至多只有一种优先关系的算符文法。
**** 素短语
至少含有一个终结符，并且本身不再含有其它素短语。
** LR(k)分析法
LR(k)分析法是一种自左向右自底向上的规范规约分析法。
-----
* 属性文法和语法制导翻译
** 属性文法
*** 属性分类
- 综合属性：用于自下而上传递消息；
- 继承属性：用于自上而下传递消息；
** 基于属性文法的处理方法
*语法制导翻译过程*
1. 输入串；
2. 语法树；
3. 依赖图；
4. 语义规则计算；
*** 良定义文法
如果一文法的任一语法树的依赖图中无循环，则该文法是良定义的。
** S属性文法的自下而上计算
*** S属性文法
文法中符号的属性只是综合属性。
** L属性文法和自顶向下翻译
*** L属性文法
对于文法中每个产生式
 A->X_1 X_2 X_3 ... X_n ,X_j (1 \le j \le n) 
X_j 的继承属性仅依赖于：
1. 产生式X_j 的左边符号X_1 ,X_2 ,X_(j-1) 的属性；
2. A的继承属性；
*** 翻译模式
*** 自顶向下翻译
-----
* 语义分析和中间代码产生
** 中间代码
*** 三元式
*** 四元式
** 赋值语句到四元式的翻译
** 布尔表达式的翻译
** 控制语句的翻译
** 数组元素的引用
** 过程调用
-----
* 代码优化
*定义*:对程序实施各种等价变换，使得变换后程序能生成高效率的目标代码。
*高效率的目标代码*:
1. 占用存储空间少；
2. 运行时间短；
** 分类
*** 根据是否涉及 /具体计算机/
**** 与机器有关的优化
(优化工作主要在目标代码级上进行)
- 对寄存器的优化
- 多处理机的优化
- 特殊指令的优化
**** 与机器无关的优化
     (优化工作主要在中间代码级上进行)
*** 根据优化对象所涉及的 /程序范围/
**** 局部优化
局限于程序基本块范围内的一种优化，包括：
- 合并已知量
- 删除公共子表达式
- 删除无用赋值
**** 循环优化
对循环中代码进行优化，包括：
- 代码外提
- 删除归纳变量
- 强度削弱
**** 全局优化
在整个程序范围内进行的优化，需要进行数据流分析，花费代价高。
*** 使用DAG实现局部优化
**** 基本块
指程序中一组顺序执行的语句序列，其中只有一个入口语句和出口语句。
**** 划分基本块的方法
入口语句和出口语句之间组成一个基本块。
***** 确定基本块入口语句 
1. 四元式序列的第一个语句；
2. 由条件转移语句或无条件转移语句转移到的语句；
3. 紧跟在条件转移语句后面的语句；
***** 确定基本块出口语句
1. 下一个入口语句的前导语句；
2. 转移语句（包含本身）；
3. 停语句（包含本身）；
*** 循环查找
1. 求流图中所有节点的必经节点；
2. 求流图中的 *回边* ；
3. 根据回边求循环。
-----
* 运行时存储空间组织
** 静态存储管理 FORTRAN存储分配
*** FORTRAN程序的特点
- 不允许过程的递归性；
- 每一个数据名的性质完全确定；
- 每一个数据名所需存储空间大小是常量；
*** 结论
整个程序所需数据空间大小、位置在编译时是完全可以确定的。
** 简单栈式存储分配（动态）C语言
*** 要求
- 无分程序结构；
- 过程定义无嵌套，但允许过程递归调用；
- 允许过程含有可变数组；
** 堆式动态分配策略
在栈式动态分配的要求上增加：
- 允许用户动态申请和释放存储空间
